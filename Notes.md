<center>基础不牢, 地动山摇</center>

# 标准库

## iostream

> istream + ostream

- cin
- cout
- cerr: 输出警告和错误信息
- clog: 输出程序运行时的一般性信息
- <<: 输出运算符
  - 接收两个运算对象: 左侧一个ostream对象, 右侧一个要打印值. 
  - 作用: 将要打印的值写到ostream对象中, 然后输出那个ostream对象
  - `std::cout<<a<<b;` 这两个输出运算符的左侧运算对象是同一个
- \>>: 输入运算符
  - 接收两个运算对象: 左侧一个istream对象, 右侧一个运算对象. 
  - 作用: 从给定的istream读入数据, 并存入指定对象中. 返回其左侧运算对象, 如std::cin. 
- endl: 操纵符(manipulator) 结束当前行, <u>并将与设备关联的缓冲区(buffer)中的内容刷到设备中</u>. 
  - 缓冲刷新操作可以保证: 到目前为止程序所产生的所有输出都真正写入输出流中, 而不是停留在内存中等待写入流. 

# 基本类型

- 分为 算术类型(arithmetic type) 和 空类型(void)
  - 算术类型: 字符, 整型数, 布尔值, 浮点数
  - 空类型: 不对应具体的值

## short

> 短整型 16位

## int

> 整型 16位

- unsigned int, 缩写 unsigned

## long

> 长整型 32位

## long long

> 长整型 64位
>
> C++11

## char

- 分为 char, signed char, unsigned char. <u>由于字符的表现形式只有两种, 因此编译器会决定char表现为另外两种形式中的一种(不同编译器可能会不一样).</u> 

## double

- 浮点数运算使用double. 因为float精度不够, 且速度不一定快. 而long double运行损耗又不容忽视. 

## 字面值常量

> literal
>
> eg. 一个数字等

- 每个字面值常量都对应一种数据类型, 字面值常量的形式和值决定了它的数据类型

### 类型

- 整型字面值

  - eg. 数值20: 十进制20, 八进制024, 十六进制0x14
  - 默认十进制字面值是带符号数, 八, 十六不确定
  - 十进制字面值的类型是能容纳当前值的int, long, long long中最小尺寸那个. 尽管整型字面值可以存储在带符号数据类型中, 但<u>严格说十进制字面值不会是负数</u>. 一个形如负数的十进制字面值, 它的负号是不在字面值之内的, 负号的作用是对字面值取负值而已. 
  - 八, 十六进制是在int, unsigned int, long, unsigned long, long long, unsigned long long中选尺寸最小的那个

- 浮点型字面值是一个double

- 字符字面值是一个char

- 字符串字面值是由常量字符构成的数组

  ```cpp
  std::cout<<"a long
  		  "long literal"<<std::endl
  ```

  虽然分两行, 但这是一个字符串字面值

- 转义序列

  - 如\n, \t

  - 泛化的转义序列: 形式是\x后紧跟1个或多个十六进制数字, 或者\后面跟1个, 2个或<u>3</u>个<u>八进制</u>数字. ([1], p37)

    ![image-20210110205856549](Notes.assets/image-20210110205856549.png)

- 指定字面值类型

  ![image-20210110192833678](Notes.assets/image-20210110192833678.png)

  ![wchar_t](Notes.assets/image-20210110192957904.png)

  - 1024f必须写成1024.f

- 布尔字面值: true, false

- 指针字面值: nullptr

## (un)signed

- 如果表达式中既有带符号类型又有无符号类型, 那么带符号数会自动转换为无符号数. (如果这个带符号数是负的, 那结果

# 复合类型

> compound type
>
> 基于其他类型定义的类型

## 引用

- 为对象起另一个名字, 即别名
- 引用必须被初始化

### 引用的定义

```cpp
int i = 1024, &r = i;
int &refVal = 10;  // ERROR, 字面值非对象
```

- 因为引用本身不是一个对象, 因此不能定义引用的引用
- 引用只能绑定在对象上
- 定义引用时程序把引用和它的初始值绑定(bind)在一起, 一旦绑定无法更改
- 引用的类型要和与之绑定的对象严格匹配, 除了...

### 左值引用

> lvalue reference
>
> 通常说引用说的是左值引用

### 右值引用

> rvalue reference



## 指针

- 指向另一种类型的复合类型

### 与引用的比较

- 都是实现了对其他对象的间接访问
- 指针本身就是一个对象, 允许对指针赋值和拷贝
- 指针可以先后指向不同对象
- 指针可以为空, 引用不可以, 一定要赋初值

### 初始化

- 引用没有实际地址(非对象), 指针不能指向引用
- 指针的类型要和它所指向的对象严格匹配, 除了...

:fist_right: 指针要初始化, 为`nullptr`或其他

### 解引用符

```cpp
int ival = 42;
int *p = &ival;
cout<<*p;
```

### 空指针

生成方法

```cpp
int *p1 = nullptr;  // best
int *p2 = 0;
int *p3 = NULL;  // #include cstdlib
```

### 指针值

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置:question:
  - 一个指针指向某个对象, 同时另一个指针指向另外对象的下一个地址, 此时有可能两个指针值相同
- 空指针(没有指向任何对象)
- 无效指针(不是上述的任何情况)

### void*

> 一种特殊的指针类型, 可以存放任意对象的地址

```cpp
double obj = 3.14, *pd = &obj;

void *pv;
pv = &obj;  // 指向double
pv = pd;    // 指向double指针
```

- 可以做的: 和别的指针比较, 作为函数的输入输出, 给另一个void*指针赋值
- 不能做的: 不能直接操作void*指针所指的对象(因为不知道这个对象的类型)

# 变量

## 变量定义

> 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储

### 初始化

- **初始化不是赋值**, 初始化的含义是创建变量时赋予其一个初始值, 而赋值的含义是把对象的当前值擦除, 然后以一个新值替代. 

#### 列表初始化

> list initialization

- 初始化或者是为对象赋新值都可以使用这样一组由花括号括起来的初始值. 

```cpp
int a = {0};  // 注意是int哦
int b{0};
```

- 重要特点: <u>如果使用列表初始化且初始值存在丢失信息的风险, 则编译器会报错</u>(或warning):

  ```cpp
  long double ld = 3.1415926536;
  int a{ld};  // warning
  int b = {ld};  // warning
  int c(ld);
  int d = ld;
  ```

#### 默认初始化

> default initialization

- 变量被赋予默认值, 默认值是什么由变量类型和(某些情况下)变量的位置决定
  - 如果内置类型的变量未被显式初始化, 它的值由定义的位置决定: 定义于任何函数体之外的变量被初始化为1; <u>定义在函数体内部的内置类型将**不被初始化**(uninitialized).</u> 

#### 显式初始化

### 与声明的关系

> definition & declaration

- 为了支持分离式编译(separate compilation, 允许将程序分为若干个文件, 每个文件可被单独编译), 同时文件之间又需要共享代码(一个文件可能用到另一个文件的变量), C++将声明和定义区分开来.
  - 声明: 使名字为程序所知, 定义变量的类型和名字
  - 定义: 负责创建与名字关联的实体 定义变量的类型和名字, 申请存储空间, 可能还有为变量赋初始值

```cpp
extern int i;      // 声明i, 但不定义i
int j;         	   // 声明并定义j
extern int k = 3;  // 声明并定义k, 赋初值抵消了extern的作用
```

- :exclamation: 如果在函数体内部试图初始化一个由extern关键字标记的变量, 将引发错误

- <u>变量能且只能被定义一次, 但可以被多次声明</u> 
- 如果在多个文件中使用同一个变量, 就必须将声明和定义分离: <u>变量的定义必须且只能出现在一个文件中, 而其他用到该变量的文件必须对其进行声明, 却绝对不能重复定义</u>

## 变量声明

- 一条声明语句有一个**基本数据类型 (base type)**和紧随其后的一个**声明符 (declarator)**列表组成
  - 每个声明符命名了一个变量, 并指定该变量为与基本数据类型有关的某种类型
  - 声明符可以是变量名, 此时变量的类型也就是声明的基本数据类型
  - 还有更复杂的声明符

## 标识符

> identifier

- 定义在函数体外的标识符不能以下划线开头

:fist_right: 变量名一般用小写字母, 用户自定义的类名一般以大写字母开头

## 作用域

### 全局作用域

> global scope

### 块作用域

> block scope

### 内层作用域

> inner scope

### 外层作用域

> outer scope



# ghost

> 尚没在框架中找到合适位置的"孤魂野鬼"

- Windows的可执行文件是 .exe, UNIX系统通常是 .out, 或者没有后缀
- C++是一种静态数据类型(<u>静态类型</u>, statically typed)语言, 它的类型检查发生在编译时(检查类型的过程称为类型检查type checking): 编译器会检查数据类型是否支持要执行的运算, 如果支持, 编译器会报错且不会生成可执行文件. 

# Reference

- [1] C++ Primer 5th

# FYI

- :exclamation:: 注意, 容易出错的地方
- :question:: 尚无法理解
- :fist_right:: best practice
- <u>UNDERLINE</u>: 之前没有注意过的内容